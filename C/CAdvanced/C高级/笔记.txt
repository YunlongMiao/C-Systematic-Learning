
sizeof：运算符，返回值：unsigned int
	无符号类型运算结果为无符号类型
	其他用法：统计数组占用内存空间大小


数组作为形参时，退化为指针

void *calloc(size_t nmemb, size_t size);
功能：
在内存动态存储区中分配nmemb块长度为size字节的连续区域。calloc自动将分配的内存	置0。
参数：
nmemb：所需内存单元数量
size：每个内存单元的大小（单位：字节）
返回值：
	成功：分配空间的起始地址
失败：NULL


#include <stdlib.h>
void *realloc(void *ptr, size_t size);
功能：
重新分配用malloc或者calloc函数在堆中分配内存空间的大小。
realloc不会自动清理增加的内存，需要手动清理，如果指定的地址后面有连续的空间，那么就会在已有地址基础上增加内存，如果指定的地址后面没有空间，那么realloc会重新分配新的连续内存，把旧内存的值拷贝到新内存，同时释放旧内存。
参数：
ptr：为之前用malloc或者calloc分配的内存地址，如果此参数等于NULL，那么和realloc与malloc功能一致
size：为重新分配内存的大小, 单位：字节
返回值：
成功：新分配的堆内存地址
失败：NULL
  


数据区，堆，栈，静态区，常量区，全局区，字符串常量区，文字常量区，代码区等等，
初学者被搞得云里雾里。在这里，尝试捋清楚以上分区的关系。

数据区包括：堆，栈，全局/静态存储区。
全局/静态存储区包括：常量区，全局区、静态区。
常量区包括：字符串常量区、常变量区。
代码区：存放程序编译后的二进制代码，不可寻址区。

可以说，C/C++内存分区其实只有两个，即代码区和数据区


栈的生长方向和内存存放方向：
	栈的生长方向：
		经过测试，在Windows平台vs上面，程序选择32位和64位结果不同，
		32位栈向下生长，64位向上生长
	
	内存存放方向：
		小端模式

小端：是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。如Intel  x86结构就是使用小端模式。

大端：是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。如IBM  power PC结构就是使用的大端模式。

首先要知道不管是大端还是小端，cpu在读取和存储数据的时候一定都是从内存的低地址依次向高地址读取或写入。
